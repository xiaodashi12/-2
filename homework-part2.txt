1、
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
a[6]();
10
i是全局变量，for循环执行完，i是10，所以之后无论调用a几，输出的都是10。
var a = [];
for (let i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
a[6]();
将var 变成let则会输出6

2、
var tmp = 123;
if (true) {
    console.log(tmp);
    let tmp;
}
let是声明变量， 会形成块级作用域和封闭作用域，
所以 tmp 无法拿到全局 var 声明的值，只能在块级作用域中查找。
let 不会导致变量提升，因此console.log(tmp)无法找到声明，导致报错
3、
var arr = [12, 34, 32, 89, 4];
var min1 = Math.min(...arr)
console.log(min1)
4、
var 全局作用域，可以重复定义，多次赋值，会存在变量提升
let 块级作用域，不可以重复定义，可以多次赋值，不存在变量提升，所以不能声明前访问，会造成暂时性死区
const 块级作用域，不可以重复定义，不可以多次赋值。
基本数据类型不能修改，引用数据类型可以修改内部的值，因为实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
不会存在变量提升，所以不能声明前访问，会造成暂时性死区
5、
var a = 10;
var obj = {
    a: 20,
    fn () {
        setTimeout(() => {
            console.log(this.a);
        });
    }
}
obj.fn();
setTimeout是箭头函数，this指向不会发生变化指向fn，而是obj,所以输出20
var a = 10;
var obj = {
    a: 20,
    fn () {
        setTimeout(function() {
            console.log(this.a);
        });
    }
}
obj.fn();
输出10
6、
作为对象的属性，可以作为对象的私有属性，
主要用处是为对象添加一个独一无二的属性值

7、

浅拷贝：
基本类型：name,val 存储在栈内存中，浅拷贝时栈内存会新开辟一个内存，因此改变一个不会影响另外一个
引用数据类型: key 存在栈内存中，val存在于堆内存中，栈内存会提供一个引用的地址指向堆内存中的值
浅拷贝时，其实复制的是的引用地址，因此改变一个会影响另外一个

深拷贝：
针对的就是引用数据类型，Object、Array,会在栈内存中开辟一个内存，新拷贝的key在堆内存指向那个新的地址，这样新旧数据就不会有影响

8、
TS
一门基于Javascript之上的编程语言，重点解决Javascript类型系统的问题，大大提高代码的可靠程度。
可以在编译期间发现并纠正错误，
不允许任意的隐式类型转换，更强的语言类型约束，语言层面限制了实参类型必须与形参类型相同
JS
作为一种解释型语言，只能在运行时发现错误
运行时才能确定变量类型，而且变量类型可以发生明显的变化
允许任意的隐式类型转换，几乎没有语言类型约束

9、
优点：

1、错误更早的暴露
2、代码更加智能，编码更加准确
3、重构代码更牢靠
4、减少一些不必要的类型判断

缺点：
1、相对于js多了很多概念，增加了学习成本、但是可以用js语法使用，渐进式
2、周期比较短的项目，不适合，长周期维护的大型项目可以使用


10、
核心思想：设置引用数，判断当前引用数是否为0
引用计数优点
	发现垃圾立即进行回收
	最大限度减少程序的暂停
引用计数缺点
	时间开销巨大，速度比较慢
	无法回收循环引用的对象

11、
标记整理可以看做标记清除的增强
前期依然是遍历整个对象，并且标记可达对象
但是清除阶段时会先执行整理，移动对象的位置，将活动对象放在一起
清除没有标记的对象，同时把第一次遍历所做的标记抹掉
优点： 减少了内存空间的碎片化，缺点：也是无法回收垃圾对象

12、
回收过程采用复制算法和标记整理
新生代内存去分为两个等大的空间
使用空间为from，空闲空间为To
活动对象分配至from空间，
标记整理后将活动对象拷贝到To
from与To交换空间完成释放

13、
使用时机：会穿插在程序的运行中执行。
​ 工作原理： 对象存在直接可达和间接可达，将遍历对象标记，拆分成多个小步骤，先标记直接可达对象。
间接可达的标记与程序执行交替执行，最终完成清除。
